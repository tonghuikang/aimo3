Correct answer: 78498

Correct approach
- For 3-heap Nim, losing positions satisfy nim-sum zero, so require `n XOR 2n XOR 3n = 0`.
- Rearrange to `n XOR 2n = 3n = n + 2n`.
- Use `a + b = (a XOR b) + 2(a AND b)`: equality of sum and xor is equivalent to `a AND b = 0`, so we need `n AND (2n) = 0`.
- Since `2n = n << 1`, this means the binary expansion of `n` has no adjacent 1s.
- Count such `n` for `1 <= n <= 2^30`.
- For numbers in `[0, 2^30 - 1]` (30-bit strings with leading zeros), the count with no adjacent 1s is `F_{32}`.
- Endpoint handling: `0` is included in that `F_{32}` count, while `2^30` is also valid and must be included. So positive count up to `2^30` is `(F_{32} - 1) + 1 = F_{32}`.
- `F_{32} = 2,178,309`, and `2,178,309 mod 99,991 = 78,498`.

Wrong approaches and why they fail
- Off-by-one (forgetting to include `n = 2^30` after excluding `0`): uses `F_{32} - 1`, giving wrong result `78,497`.
- Off-by-one (adding `2^30` but forgetting that `0` was already included in the base count): uses `F_{32} + 1`, giving wrong result `78,499`.
- Overcounting by treating the bound like all 31-bit numbers (`0` to `2^31-1`): uses `F_{33}` (or positives `F_{33}-1`), giving wrong modulo results `24,893` (or `24,892`).
