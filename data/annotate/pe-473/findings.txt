## Problem: pe-473 - Phigital Palindromes

### Correct Answer: 96175

### Correct approach
- Palindrome is on the full phigital string (including the point). For point-palindromes, left and right digit lengths are equal and right side is the reverse of left side.
- Let left bits be `a_{k-1}...a_0` (with exponent `i` for bit `a_i`). Point-palindrome value is:
  - `n = sum_{i=0..k-1} a_i (phi^i + phi^{-(i+1)})`
- Because exponent `0` and exponent `-1` are adjacent and mirrored, `a_0` is forced to `0`.
- `1` is a special case: the no-point representation `"1"` is palindromic and must be included separately.
- Using `phi^i = F_i*phi + F_{i-1}` and `phi^{-(i+1)} = (-1)^i(F_{i+1}*phi - F_{i+2})`, integer-valid palindromes satisfy the balance condition:
  - `sum_{even i>=2, a_i=1} F_{i+2} = sum_{odd i>=3, a_i=1} F_{i-1}`
- Enumerate valid left strings (or equivalent block/weight constructions), keep values `<= 10^10`, include `1`, then sum modulo `99991`.
- Sanity check: for `N=1000`, valid values sum to `4345`.

### Wrong approaches and why they fail
- Over-restricting to only two simple families (e.g., pure repeated `100`-block forms plus a single prefix family) misses many valid palindromes (fails the `N=1000` check; produces too small a sum).
- Generating candidates without enforcing canonical constraints (leading bit must be `1`, no consecutive `1`s, `a_0=0`) introduces invalid/spurious representations.
- Relying only on rounded decimal evaluation (without algebraic/equality validation or sufficient precision) can misclassify candidates near integer boundaries.
- Pure brute-force recursion over long bit-lengths without structural pruning is too slow; it needs either algebraic constraints or structured grammar/DP-style generation.
