## Correct answer
- `F(10^7) mod 99991 = 80848`.

## Correct approach
- Work on the prime-only graph.
- A prime `P` is a 2's relative iff, in the induced graph of primes `<= P`, node `P` is connected to `2`.
- Process primes in increasing order with DSU:
  - Add prime `p`.
  - Union `p` with smaller prime neighbors from rule (1): same length, exactly one digit changed, no leading-zero result.
  - Union `p` with smaller prime neighbor from rule (2) only when valid by exact one-digit-left semantics:
    - For `k = len(p)`, let `q = p mod 10^(k-1)`.
    - `q` is a valid rule-(2) neighbor only if it has length `k-1`, i.e. `q >= 10^(k-2)` (for `k >= 2`), and `q` is prime.
- After processing unions for `p`, classify `p` immediately:
  - connected to `2` => relative
  - otherwise contributes to `F`.
- This reproduces checkpoints `F(10^3)=431`, `F(10^4)=78728`, and gives `F(10^7) mod 99991 = 80848`.

## Wrong approaches and why they fail
- Treating every left-truncation as valid rule (2):
  - Wrongly allows edges like `103 <-> 3` (from `103 -> 03`), which is not a one-digit prepend relation.
  - Over-connects the graph and yields too-small non-relative sums (e.g., `112` at `10^3`).
- Misreading DSU dynamics:
  - Seeing later merges and concluding incremental DSU is invalid for per-prime status.
  - The per-prime check is done at insertion time (`<= p` graph), so DSU is still correct.
- Using a "reachable-set only" validator:
  - Tracking only currently relative primes misses that previously non-relative primes can later become bridges for larger targets.
  - Causes false mismatches against the correct DSU classification.
