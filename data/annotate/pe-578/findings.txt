# PE 578 Findings

## Correct answer
- `C(10^13) = 9219696799346`
- `C(10^13) mod 99991 = 46740`

## Correct approach
- Let prime exponents in ascending-prime order be nonincreasing.
- Split counting into:
  - A squarefree tail counter `S(M, a)`: squarefree integers `<= M` with all prime factors greater than the `a`-th prime.
  - A recursive core for exponents `>= 2`.
- Use:
  - `C(N) = S(N, 0) + R(0, N, floor(log_2 N))`
  - `R(i, rem, E) = sum_{e=2..E} sum_{j>=i, p_j^e<=rem} [ S(rem / p_j^e, j+1) + R(j+1, rem / p_j^e, e) ]`
- Compute `S` with Möbius + Legendre-phi style filtering:
  - `S(M, a) = sum_{d<=sqrt(M), mu(d)!=0, spf(d)>p_a} mu(d) * phi(floor(M/d^2), a)`
  - `phi(x, a)` counts integers `<= x` not divisible by the first `a` primes.
- Required base-case handling:
  - `phi(x,0)=x`, `phi(0,a)=0`
  - If `p_a > x`, reduce `a` correctly (do not return `x` directly)
  - For `S(M,a)` shortcut:
    - If `p_a > M`, then `S(M,a)=1`
    - Else if `p_a > sqrt(M)`, then `S(M,a)=1 + pi(M) - a`
- Validate against checkpoints:
  - `C(100)=94`
  - `C(10^6)=922052`

## Wrong approaches and why they fail
- **Direct enumeration of all valid integers**:
  - Infeasible because the final count is on the order of `10^13` (`~9.22e12`).
- **Only enforcing “all later exponents <= e” for a chosen leading exponent**:
  - Overcounts by allowing exponent rises after a drop, violating full nonincreasing order.
- **Recursing tail search from prime index 0 after choosing a prime**:
  - Reuses the same prime multiple times as if distinct positions, causing invalid duplicates.
- **Using `S(M,a)=1+pi(M)-a` whenever `p_a>sqrt(M)` without checking `p_a>M`**:
  - Undercounts small-`M` states; one broken variant produced `C(10^6)=888907` instead of `922052`.
- **Density/approximation fallback instead of exact counting**:
  - Produces incorrect outputs (including placeholder `0` in one trace).
