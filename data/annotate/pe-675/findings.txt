# pe-675 findings

## Correct answer
- \(F(10{,}000{,}000) \bmod 1{,}000{,}000{,}087 = 416146418\).

## Correct approach
- Use multiplicativity:
  - For \(n=\prod p^{e_p}\), \(S(n)=\sum_{d\mid n}2^{\omega(d)}=\prod_p (1+2e_p)=\prod_p(2e_p+1)\).
- Apply to factorials:
  - \(S(i!)=\prod_{p\le i}(2e_p(i!)+1)\), where \(e_p(i!)=e_p((i-1)!)+v_p(i)\).
- Maintain a rolling value \(cur=S(i!)\):
  - For each prime \(p^a\parallel i\), update
    - \(e_{\text{old}}=e_p((i-1)!)\), \(e_{\text{new}}=e_{\text{old}}+a\)
    - \(cur \leftarrow cur\cdot(2e_{\text{new}}+1)\cdot(2e_{\text{old}}+1)^{-1}\pmod M\).
- Sum \(cur\) for \(i=2\) to \(N\) modulo \(M=1{,}000{,}000{,}087\).
- Use SPF sieve to factor each \(i\) quickly; this gives practical \(O(N\log\log N)\)-style behavior.

## Wrong approaches and why they fail
- Recomputing \(S(i!)\) from scratch for every \(i\) using full Legendre products over all primes:
  - Too slow for \(N=10^7\) (effectively superlinear with a large constant), likely timeout.
- Using Python object-heavy arrays/lists for large tables (`spf`, `exp`, inverse table):
  - Can exceed memory limits (OOM) before producing an answer.
- Updating in modular arithmetic via integer division without modular inverse handling:
  - Algebraically invalid modulo \(M\); can produce incorrect transitions for \(S(i!)\).
- Overusing per-update expensive inverse computation without optimization:
  - Can make runtime impractical at \(N=10^7\), leading to no final result in time.

## Trace-level outcome summary
- The completed traces for this state converge to the same correct value: 416146418.
