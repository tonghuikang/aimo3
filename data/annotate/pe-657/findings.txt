Problem: Count incomplete words (words missing at least one letter) over alphabet size alpha with length <= n.

Correct answer for alpha = 10^7, n = 10^12 (mod 1,000,000,007): 219493139

Correct approach:
- Use inclusion-exclusion on missing letters:
  I(alpha,n) = sum_{i=1}^{alpha} (-1)^{i+1} C(alpha,i) * G(alpha-i)
- G(m) = sum_{k=0}^n m^k with edge cases:
  - G(0)=1
  - G(1)=n+1
  - G(m)=(m^{n+1}-1)/(m-1) for m>=2 (mod M via inverse)
- Equivalent rewrite with m = alpha-i:
  I(alpha,n) = (-1)^{alpha+1} * sum_{m=0}^{alpha-1} (-1)^m C(alpha,m) G(m)
- Modular arithmetic:
  - M = 1,000,000,007 is prime
  - exponent reduction: e = (n+1) mod (M-1) = 999,994,007
  - use pow(m,e,M) for m^{n+1} mod M
- O(alpha) implementation is feasible:
  - precompute modular inverses inv[1..alpha] in O(alpha): inv[i]=M-(M//i)*inv[M%i] mod M
  - update binomial coefficients incrementally instead of factorial tables
  - loop once across m=0..alpha-1

Wrong approaches and failure modes:
- False Stirling-prefix identity:
  - Incorrect claim: sum_{k=0}^n S(k,alpha) = S(n+1,alpha+1)
  - Counterexample: alpha=3,n=4 gives wrong I=61 instead of true I=79
- Dominant-term/approximation shortcut:
  - Keeping only leading inclusion-exclusion behavior (e.g., alpha*(alpha-1)^k) is not exact modulo M
  - misses essential cancellation across many terms, so residue is wrong
- Sign-parity rewrite bug:
  - Wrong rewrite: I = sum_{m=0}^{alpha-1} (-1)^{m+1} C(alpha,m) G(m) (used unconditionally)
  - Correct sign is (-1)^{alpha+1}(-1)^m
  - For odd alpha this flips answers (example alpha=3,n=2 gives -13 instead of 13 before mod normalization)
