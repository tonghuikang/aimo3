## Problem: pe-623 (Lambda-calculus term enumeration)

### Correct Answer
3679796

### Problem Summary
Count closed lambda terms (up to alpha-equivalence) with at most `n=2000` symbols, modulo `1,000,000,007`.
Counted symbols are: `(`, `)`, `lambda`, `.`, and variable letters.

### Correct Modeling
Use de Bruijn indices so alpha-equivalent terms collapse to one representation.
Let `B[d][s]` be the number of terms of exact size `s` in an environment with `d` available binders.

Size rules:
- Variable leaf: `1`
- Abstraction `(lambda x.M)`: `5 + |M|`
- Application `(M N)`: `2 + |M| + |N|`

Recurrence:
- `B[d][1] = d`
- Abstraction contribution (for `s >= 6`): `B[d+1][s-5]`
- Application contribution: `sum_{i=1}^{s-3} B[d][i] * B[d][s-2-i]`

Closed terms are `B[0][s]`; answer is `sum_{s=1..2000} B[0][s] mod 1e9+7`.
Depth only needs to go to `floor((n-1)/5) = 399`.

### Correct Approach (practical)
A depth-by-size DP with the above recurrence is sufficient and reproduces all provided checks (`Lambda(6)=1`, `Lambda(9)=2`, `Lambda(15)=20`, `Lambda(35)=3166438`) before computing `Lambda(2000)`.

### Wrong Approaches and Why They Fail
- Abstraction-size miscount (`4 + |M|` instead of `5 + |M|`):
  Produces the wrong shift (`s-4`), which breaks sample consistency.
- Assuming `F_d` is linear in depth (`F_d = d*X + Y`):
  Incompatible with the quadratic term `F_d^2`; higher-order dependence on `d` is unavoidable.
- Incorrect coefficient subtraction in quadratic-series implementation:
  Treating numerator coefficients as `1 - sqrt[i]` for all `i` is wrong; only degree 0 has the `1` term. This yields wrong checkpoint values (e.g., incorrect `Lambda(6)`).
- Using unrelated NTT moduli without a valid reconstruction argument:
  Residues modulo other primes alone do not determine values modulo `1e9+7` unless reconstruction conditions are satisfied.
