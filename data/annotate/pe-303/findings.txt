Correct answer: 54449

Correct approach
- Let `S(N) = sum_{n=1..N} f(n)/n`, where `f(n)` is the smallest positive multiple of `n` using only decimal digits `{0,1,2}`.
- For fixed `n`, compute `f(n)` with BFS on remainder states modulo `n`:
  `r -> (10*r + d) mod n`, `d in {0,1,2}`, with starting digits `1` and `2` (no leading zero).
- Use parent-remainder and appended-digit arrays to reconstruct the first remainder-0 path; this gives the minimal valid decimal value.
- The BFS order gives the minimal number (shorter length first, then lexicographically smallest among equal lengths).
- Compute each term as integer `f(n)/n`, sum for `n=1..10000`, then reduce modulo `99991`.
- Sanity check: for `N=100`, this reproduces the provided `11363107`.
- The full sum for `N=10000` is `1111981904675169`, so modulo `99991` it is `54449`.

Wrong approaches and why they fail
- Raw number-generation BFS with a fixed numeric cutoff (for example stopping at `10^k`) is not guaranteed to find the true `f(n)` for all `n`; it can silently miss the minimal valid multiple.
- Contribution-by-divisors scans over all numbers in `A = {decimal numbers using only 0,1,2}` without a proven bound are impractical here and do not give a reliable stopping criterion.
- Quick manual sanity arithmetic can be misleading if the minimum condition is not enforced (e.g., assuming `f(5)=20` instead of the smaller valid `10`), which produces incorrect check sums.
