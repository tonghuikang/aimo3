Correct answer
- `f(10^18) mod 1000267129 = 819963842`.

Correct approach
- Let `N = n - 1`; we count pairs in `[1, N]`.
- Compute `total_pairs = C(N, 2)`.
- Let `c[mask]` be the count of numbers in `[1, N]` whose set of used decimal digits is exactly `mask`.
- Use digit DP with state `(pos, tight, started, mask)` to compute all `c[mask]`:
  - `started=0` means still in leading zeros (do not add digit `0` to the mask there).
  - Exclude terminal states with `started=0` so number `0` is not counted.
- Count non-friend pairs (disjoint digit sets):
  - `nonfriend = (1/2) * sum_{a,b: (a & b)=0} c[a]c[b]`.
- Then `f(n) = total_pairs - nonfriend` (modulo `1000267129`).
- Since the modulus is odd, division by 2 is valid via `inv2 = (M+1)/2`.

Wrong approaches and why they fail
- Summing over subset-allowed counts directly (e.g., numbers whose digits are subsets of `A` and `B`) without Mobius/exact-mask correction double-counts many numbers and gives the wrong pair count.
- Treating leading zeros as real digit `0` corrupts masks (inflates zero-containing masks) and breaks disjoint-pair totals.
- Assuming the modulus is prime is unsafe here (`1000267129 = 31627^2`): generic Fermat-based inverse logic is not justified in general. Here halving still works only because `gcd(2, M)=1`.
